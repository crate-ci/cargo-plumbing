use std::io::{self, BufReader, IsTerminal, Write};
use std::path::PathBuf;

use anyhow::Context;
use cargo::core::SourceKind;
use cargo::util::Filesystem;
use cargo::{CargoResult, GlobalContext};
use cargo_plumbing_schemas::lock_dependencies::LockDependenciesMessage;
use cargo_plumbing_schemas::lockfile::{NormalizedDependency, Precise};
use url::Url;

#[derive(Debug, clap::Args)]
pub(crate) struct Args {
    /// Path to the lockfile
    #[clap(long)]
    lockfile_path: PathBuf,
}

pub(crate) fn exec(gctx: &mut GlobalContext, args: Args) -> CargoResult<()> {
    let stdin = io::stdin();
    if stdin.is_terminal() {
        anyhow::bail!("input must be piped from a file or another command");
    }

    let messages = LockDependenciesMessage::parse_stream(BufReader::new(stdin));

    let mut lock_version: Option<u32> = None;
    let mut locked_packages = Vec::new();
    let mut unused_patches = None;

    for message in messages {
        match message? {
            LockDependenciesMessage::Lockfile { version } => lock_version = version,
            LockDependenciesMessage::LockedPackage { package } => locked_packages.push(package),
            LockDependenciesMessage::UnusedPatches { unused } => unused_patches = Some(unused),
            _ => {}
        }
    }

    let lock_path = gctx.cwd().join(args.lockfile_path);
    let root = lock_path.parent().expect("Lockfile path can't be root");
    let lock_root = Filesystem::new(root.to_owned());

    let mut out = String::new();

    let marker_line = "# This file is automatically @generated by Cargo.";
    let extra_line = "# It is not intended for manual editing.";
    out.push_str(marker_line);
    out.push('\n');
    out.push_str(extra_line);
    out.push('\n');

    if let Some(version) = lock_version {
        out.push_str(&format!("version = {version}\n\n"));
    }

    for package in locked_packages {
        out.push_str("[[package]]\n");
        emit_package(package, &mut out);
    }

    if let Some(unused_patches) = unused_patches {
        for patch in unused_patches.unused {
            out.push_str("[[patch.unused]]\n");
            emit_package(patch, &mut out);
        }
    }

    if let Some(v) = lock_version {
        if v >= 2 {
            while out.ends_with("\n\n") {
                out.pop();
            }
        }
    }

    lock_root
        .open_rw_exclusive_create("Cargo.lock", gctx, "Cargo.lock file")
        .and_then(|mut f| {
            f.file().set_len(0)?;
            f.write_all(out.as_bytes())?;
            Ok(())
        })
        .with_context(|| {
            format!(
                "failed to write {}",
                lock_root.as_path_unlocked().join("Cargo.lock").display()
            )
        })?;

    Ok(())
}

fn emit_package(package: NormalizedDependency, out: &mut String) {
    out.push_str(&format!("name = \"{}\"\n", package.id.name()));

    if let Some(version) = package.id.version() {
        out.push_str(&format!("version = \"{version}\"\n"));
    }

    if let Some(url) = package.id.url() {
        if let Some(kind) = package.id.kind() {
            out.push_str("source = \"");
            emit_source_value(url, kind, &package.rev, out);
            out.push_str("\"\n");
        }
    }

    if let Some(checksum) = &package.checksum {
        out.push_str(&format!("checksum = \"{checksum}\"\n"));
    }

    if let Some(deps) = &package.dependencies {
        if !deps.is_empty() {
            out.push_str("dependencies = [\n");
            for dep in deps {
                out.push_str(&format!(r#" "{}"#, dep.name()));
                if let Some(version) = dep.version() {
                    out.push_str(&format!(" {version}"));
                }
                if let Some(url) = dep.url() {
                    if let Some(kind) = dep.kind() {
                        out.push_str(" (");
                        emit_source_value(url, kind, &None, out);
                        out.push(')');
                    }
                }
                out.push_str("\",\n");
            }
            out.push_str("]\n");
        }
    }

    out.push('\n');
}

fn emit_source_value(url: &Url, kind: &SourceKind, rev: &Option<Precise>, out: &mut String) {
    if let Some(protocol) = kind.protocol() {
        out.push_str(&format!("{protocol}+"));
    }
    out.push_str(url.as_str());
    if let Some(query) = url.query() {
        out.push_str(&format!("?{query}"));
    }
    if let SourceKind::Git(git_ref) = kind {
        if let Some(pretty) = git_ref.pretty_ref(true) {
            out.push_str(&format!("?{pretty}"));
        }
    }
    if let Some(rev) = rev {
        out.push_str(&format!("#{rev}"));
    }
}
